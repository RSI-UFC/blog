<!DOCTYPE html>
<html class="no-js" lang="pt-br">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta name="theme-color" content="#1b1b1b">
	<title>Escrevendo Aplicações Nativas para Windows - Parte 3 | RSI</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="stylesheet" href="/blog/css/bundle.css">
	<link rel="icon" href="/blog/icons/16.png" sizes="16x16" type="image/png">
	<link rel="icon" href="/blog/icons/32.png" sizes="32x32" type="image/png">
		
</head>
<body class="body kind-page">
	<header class="header">
	<a class="logo" href="/blog">RSI</a>
	
<nav class="main-nav" role="navigation">
	<button id="toggle" class="main-nav__btn" aria-label="Menu toggle" aria-expanded="false" tabindex="0">
		<div class="main-nav__btn-box" tabindex="-1">
			<svg class="main-nav__icon icon-menu" width="18" height="18" viewBox="0 0 18 18">
				<path class="icon-menu__burger" d="M18 0v3.6H0V0h18zM0 10.8h18V7.2H0v3.6zM0 18h18v-3.6H0V18z"/>
				<path class="icon-menu__x" d="M11.55 9L18 15.45 15.45 18 9 11.55 2.55 18 0 15.45 6.45 9 0 2.55 2.55 0 9 6.45 15.45 0 18 2.55 11.55 9z"/>
			</svg>
		</div>
	</button>
	<ul id="menu" class="main-nav__list">
			<li class="main-nav__item">
				<a class="main-nav__link" href="/blog/authors/">
					
					<span class="main-nav__text">Autores</span>
					
				</a>
			</li>
			<li class="main-nav__item">
				<a class="main-nav__link" href="/blog/tags/">
					
					<span class="main-nav__text">Tags</span>
					
				</a>
			</li>
			<li class="main-nav__item main-nav__item--active">
				
					
					<span class="main-nav__text">Posts</span>
					
				
			</li>
	</ul>
</nav>
</header>
	<div class="primary">
	
	<main class="main">
		
		<div class="single block">
			<article class="entry">
				<h1 class="entry__title">Escrevendo Aplicações Nativas para Windows - Parte 3</h1>
				<div class="entry__content"><blockquote>
<p><em>Por Davi Chaves</em></p>
</blockquote>
<p>O objetivo desse artigo vai ser enumerar todos os processos e, em seguida enumerar todos as threads e handles de um processo específico.</p>
<h1 id="ntquerysysteminformation">NtQuerySystemInformation</h1>
<p>Essa função será usada para pegarmos quase todo tipo de informação do sistema. O primeiro parametro dela é um valor de um <em>enum</em> <code>SYSTEM_INFORMATION_CLASS</code> que vai definir que tipo de informação ela vai trazer. Abaixo a estrutura desse <em>enum</em>. Primeiramente, estaremos utilizando o valor <code>SystemProcessInformation</code> para obtermos uma lista de todos os processos.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">enum</span> _SYSTEM_INFORMATION_CLASS
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    SystemBasicInformation,
</span></span><span style="display:flex;"><span>    SystemProcessorInformation,
</span></span><span style="display:flex;"><span>    SystemPerformanceInformation,
</span></span><span style="display:flex;"><span>    SystemTimeOfDayInformation,
</span></span><span style="display:flex;"><span>    SystemPathInformation,
</span></span><span style="display:flex;"><span>    SystemProcessInformation,
</span></span><span style="display:flex;"><span>    SystemCallCountInformation,
</span></span><span style="display:flex;"><span>    SystemDeviceInformation,
</span></span><span style="display:flex;"><span>    SystemProcessorPerformanceInformation,
</span></span><span style="display:flex;"><span>    SystemFlagsInformation,
</span></span><span style="display:flex;"><span>    SystemCallTimeInformation,
</span></span><span style="display:flex;"><span>    SystemModuleInformation,
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>    SystemWorkloadAllowedCpuSetsInformation,
</span></span><span style="display:flex;"><span>    SystemCodeIntegrityUnlockModeInformation,
</span></span><span style="display:flex;"><span>    SystemLeapSecondInformation,
</span></span><span style="display:flex;"><span>    SystemFlags2Information,
</span></span><span style="display:flex;"><span>    SystemSecurityModelInformation, 
</span></span><span style="display:flex;"><span>    SystemCodeIntegritySyntheticCacheInformation,
</span></span><span style="display:flex;"><span>    SystemFeatureConfigurationInformation, 
</span></span><span style="display:flex;"><span>    SystemFeatureConfigurationSectionInformation, 
</span></span><span style="display:flex;"><span>    SystemFeatureUsageSubscriptionInformation,
</span></span><span style="display:flex;"><span>    SystemSecureSpeculationControlInformation,
</span></span><span style="display:flex;"><span>    MaxSystemInfoClass
</span></span><span style="display:flex;"><span>} SYSTEM_INFORMATION_CLASS;
</span></span></code></pre></div><h1 id="systemprocessinformation">SystemProcessInformation</h1>
<p>Para alguns valores do <em>enum</em> <code>SYSTEM_INFORMATION_CLASS</code> é esperado um buffer de tamanho fixo, já para outros é esperado um buffer de tamanho variável. Para esse último caso, o comum é chamarmos a função passando um tamanho qualquer e checarmos pelo retorno da função. Caso o retorno seja <code>STATUS_INFO_LENGTH_MISMATCH</code>, alocamos um buffer maior e chamamos a função novamente até encontrarmos o tamanho correto. Entretando, existe uma outra forma mais simples, porém errada, de fazermos esse processo. Basta chamarmos a função passando um tamanho zero e passarmos a referência de alguma variável no parâmetro <code>ReturnLenght</code>. Dessa forma, o valor real necessário para alocar o buffer será retornado nela. Pelos testes que eu fiz, isso não vai funcionar sempre, apenas para alguns valores do enum <code>SYSTEM_INFORMATION_CLASS</code>. Portanto, use apenas para testes.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span>NTSTATUS status <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>PVOID pbuffer <span style="color:#f92672">=</span> nullptr;
</span></span><span style="display:flex;"><span>ULONG size <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Query Process Information
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>status <span style="color:#f92672">=</span> <span style="color:#a6e22e">NtQuerySystemInformation</span>(SystemProcessInformation, pbuffer, <span style="color:#ae81ff">0</span>, <span style="color:#f92672">&amp;</span>size);
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;Bytes: %u</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, size);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Reserves memory
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>status <span style="color:#f92672">=</span> <span style="color:#a6e22e">NtAllocateVirtualMemory</span>(<span style="color:#a6e22e">NtCurrentProcess</span>(), <span style="color:#f92672">&amp;</span>pbuffer, <span style="color:#ae81ff">0</span>, (PSIZE_T)<span style="color:#f92672">&amp;</span>size, MEM_COMMIT <span style="color:#f92672">|</span> MEM_RESERVE, PAGE_READWRITE);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">NT_SUCCESS</span>(status)) {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;Error reserving memory (status: 0x%X)</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, status);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> status;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>status <span style="color:#f92672">=</span> <span style="color:#a6e22e">NtQuerySystemInformation</span>(SystemProcessInformation, pbuffer, size, nullptr);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">NT_SUCCESS</span>(status)) {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;Error SystemProcessInformation (status: 0x%X)</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, status);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> status;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>SYSTEM_PROCESS_INFORMATION <span style="color:#f92672">*</span>p <span style="color:#f92672">=</span> (SYSTEM_PROCESS_INFORMATION<span style="color:#f92672">*</span>)pbuffer;
</span></span></code></pre></div><p>Perceba que a primeira chamada do <code>NtQuerySystemInformation</code> está sendo passado um tamanho zero. Dessa forma, a função vai retornar um erro como valor do <em>status</em> e vai assinalar o valor da variável <em>size</em> com o valor necessário para alocar a estrutura. Com esse valor em mãos, podemos alocar memória suficiente e chamar novamente a função. Ao final, temos um <em>buffer</em> contendo informações de (quase) todos os processos. Em seguida, vamos iterar por essa lista printando os valores relevantes para nós.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">while</span>(true) {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;PID: %6u PPID: %6u T: %4u H: %6u Name: %wZ</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, <span style="color:#a6e22e">HandleToULong</span>(p<span style="color:#f92672">-&gt;</span>UniqueProcessId), <span style="color:#a6e22e">HandleToULong</span>(p<span style="color:#f92672">-&gt;</span>InheritedFromUniqueProcessId),p<span style="color:#f92672">-&gt;</span>NumberOfThreads, p<span style="color:#f92672">-&gt;</span>HandleCount, <span style="color:#f92672">&amp;</span>p<span style="color:#f92672">-&gt;</span>ImageName);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (p<span style="color:#f92672">-&gt;</span>NextEntryOffset <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>	p <span style="color:#f92672">=</span> (SYSTEM_PROCESS_INFORMATION<span style="color:#f92672">*</span>)((PBYTE)p <span style="color:#f92672">+</span> p<span style="color:#f92672">-&gt;</span>NextEntryOffset);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Com isso, temos um código que itera por (quase) todos os processos. Podemos transformar isso em uma função que retorna apenas as informações de um processo específico. Basta passar um <em>pid</em> (<em>process id</em>) desejado e compararmos dentro do loop.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (pid <span style="color:#f92672">==</span> <span style="color:#a6e22e">HandleToULong</span>(p<span style="color:#f92672">-&gt;</span>UniqueProcessId)) {
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// printf(&#34;... process information here ...&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// EnumThreads(p);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h1 id="thread-enumeration">Thread Enumeration</h1>
<p>O processo de enumeração de threads em um processo é bem simples. Em cada objeto do tipo <code>SYSTEM_PROCESS_INFORMATION</code> temos um campo contendo o número de threads e o primeiro elemento de um array de <code>SYSTEM_THREAD_INFORMATION</code>, que contem as informações que queremos.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> _SYSTEM_PROCESS_INFORMATION
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    ULONG NextEntryOffset;
</span></span><span style="display:flex;"><span>    ULONG NumberOfThreads; <span style="color:#75715e">// Número de threads
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    SYSTEM_THREAD_INFORMATION Threads[<span style="color:#ae81ff">1</span>]; <span style="color:#75715e">// Primeiro elemento do array
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>} SYSTEM_PROCESS_INFORMATION, <span style="color:#f92672">*</span>PSYSTEM_PROCESS_INFORMATION;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> _SYSTEM_THREAD_INFORMATION
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    LARGE_INTEGER KernelTime;
</span></span><span style="display:flex;"><span>    LARGE_INTEGER UserTime;
</span></span><span style="display:flex;"><span>    LARGE_INTEGER CreateTime;
</span></span><span style="display:flex;"><span>    ULONG WaitTime;
</span></span><span style="display:flex;"><span>    PVOID StartAddress;
</span></span><span style="display:flex;"><span>    CLIENT_ID ClientId;
</span></span><span style="display:flex;"><span>    KPRIORITY Priority;
</span></span><span style="display:flex;"><span>    LONG BasePriority;
</span></span><span style="display:flex;"><span>    ULONG ContextSwitches;
</span></span><span style="display:flex;"><span>    KTHREAD_STATE ThreadState;
</span></span><span style="display:flex;"><span>    KWAIT_REASON WaitReason;
</span></span><span style="display:flex;"><span>} SYSTEM_THREAD_INFORMATION, <span style="color:#f92672">*</span>PSYSTEM_THREAD_INFORMATION;
</span></span></code></pre></div><p>Dessa forma, só precisamos iterar por esse array printando os campos que estamos interessados. Além disso, note que o campo <code>ThreadState</code> é do tipo <code>KTHREAD_STATE</code>, que se trata de um <em>enum</em> com todos os estados possíveis de uma thread. É possível fazer uma função super simples que transforma esse valor em uma string para ajudar na leitura.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">EnumThreads</span>(SYSTEM_PROCESS_INFORMATION<span style="color:#f92672">*</span> p) {
</span></span><span style="display:flex;"><span>	SYSTEM_THREAD_INFORMATION<span style="color:#f92672">*</span> t <span style="color:#f92672">=</span> p<span style="color:#f92672">-&gt;</span>Threads;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> (ULONG i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> p<span style="color:#f92672">-&gt;</span>NumberOfThreads; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;TID: %6u Pri: %2u Address: 0x%p State: %s</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>,
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">HandleToULong</span>(t<span style="color:#f92672">-&gt;</span>ClientId.UniqueThread),
</span></span><span style="display:flex;"><span>			t<span style="color:#f92672">-&gt;</span>Priority,
</span></span><span style="display:flex;"><span>			t<span style="color:#f92672">-&gt;</span>StartAddress,
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// Função de mapeamento de estado para string
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#a6e22e">ThreadStateToString</span>(t<span style="color:#f92672">-&gt;</span>ThreadState));
</span></span><span style="display:flex;"><span>		t<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><pre tabindex="0"><code>PID:   4144 PPID:   2900 T:    7 H:    649 Name: procexp64.exe
TID:   9616 Pri: 15 Address: 0x0000000000000000 State: Waiting
TID:   8932 Pri: 13 Address: 0x00007FFA93BEA2D0 State: Waiting
TID:   4408 Pri: 13 Address: 0x00007FFA93BEA2D0 State: Waiting
TID:   5640 Pri: 13 Address: 0x00007FFA93BEA2D0 State: Waiting
TID:   6260 Pri: 15 Address: 0x00007FFA93BEA2D0 State: Waiting
TID:   9988 Pri: 13 Address: 0x00007FFA93BEA2D0 State: Waiting
TID:   8216 Pri: 15 Address: 0x00007FFA93BEA2D0 State: Waiting
</code></pre><h1 id="systemextendedhandleinformation">SystemExtendedHandleInformation</h1>
<p>O método para obter a lista de handles em um sistema é o mesmo método de obter a lista de handles de processos. Entretando, por algum motivo, o <code>ReturnLenght</code> não retorna o real valor necessário para alocar essa estrutura. Portanto, por simplicidade, irei apenas alocar um grande número de bytes e esperar que seja o suficiente.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span>NTSTATUS <span style="color:#a6e22e">EnumHandles</span>(DWORD pid) {
</span></span><span style="display:flex;"><span>	NTSTATUS status <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	PVOID pbuffer <span style="color:#f92672">=</span> nullptr;
</span></span><span style="display:flex;"><span>	ULONG size <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">24</span>; <span style="color:#75715e">// 8 MB
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Reserves memory
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	status <span style="color:#f92672">=</span> <span style="color:#a6e22e">NtAllocateVirtualMemory</span>(<span style="color:#a6e22e">NtCurrentProcess</span>(), <span style="color:#f92672">&amp;</span>pbuffer, <span style="color:#ae81ff">0</span>, (PSIZE_T)<span style="color:#f92672">&amp;</span>size, MEM_COMMIT <span style="color:#f92672">|</span> MEM_RESERVE, PAGE_READWRITE);
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// ... check error
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	status <span style="color:#f92672">=</span> <span style="color:#a6e22e">NtQuerySystemInformation</span>(SystemExtendedHandleInformation, pbuffer, size, nullptr);
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// ... check error
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	SYSTEM_HANDLE_INFORMATION_EX<span style="color:#f92672">*</span> p <span style="color:#f92672">=</span> (SYSTEM_HANDLE_INFORMATION_EX<span style="color:#f92672">*</span>)pbuffer;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> (ULONG_PTR i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> p<span style="color:#f92672">-&gt;</span>NumberOfHandles; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>		SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX<span style="color:#f92672">&amp;</span> h <span style="color:#f92672">=</span> p<span style="color:#f92672">-&gt;</span>Handles[i];
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (pid <span style="color:#f92672">&amp;&amp;</span> h.UniqueProcessId <span style="color:#f92672">!=</span> pid)
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;PID: %6u H: 0x%X Access: 0x%08X Address: 0x%p</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>,
</span></span><span style="display:flex;"><span>			(ULONG)h.UniqueProcessId, (ULONG)h.HandleValue, h.GrantedAccess, h.Object);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Abaixo um pedaço da saída do programa. Recomendo comparar esses valores com os valores mostrados pelo <em>procexp.exe</em>.</p>
<pre tabindex="0"><code>PID:   4144 H: 0x4 Access: 0x001F0003 Address: 0xFFFFBD8F66B810E0
PID:   4144 H: 0x8 Access: 0x001F0003 Address: 0xFFFFBD8F66B82DE0
PID:   4144 H: 0xC Access: 0x00000001 Address: 0xFFFFBD8F668B3180
PID:   4144 H: 0x10 Access: 0x001F0003 Address: 0xFFFFBD8F69295500
PID:   4144 H: 0x14 Access: 0x000F00FF Address: 0xFFFFBD8F6C5772C0
PID:   4144 H: 0x18 Access: 0x00100002 Address: 0xFFFFBD8F60274820
PID:   4144 H: 0x1C Access: 0x00000001 Address: 0xFFFFBD8F668B46A0
PID:   4144 H: 0x20 Access: 0x00100002 Address: 0xFFFFBD8F60274930
PID:   4144 H: 0x24 Access: 0x00000001 Address: 0xFFFFBD8F668B34C0
PID:   4144 H: 0x28 Access: 0x00000804 Address: 0xFFFFBD8F69294EF0
PID:   4144 H: 0x2C Access: 0x00000804 Address: 0xFFFFBD8F692949B0
PID:   4144 H: 0x30 Access: 0x00000804 Address: 0xFFFFBD8F692956D0
PID:   4144 H: 0x34 Access: 0x00000003 Address: 0xFFFFA60BF573ACE0
PID:   4144 H: 0x38 Access: 0x001F0003 Address: 0xFFFFBD8F66B82F60
PID:   4144 H: 0x3C Access: 0x001F0003 Address: 0xFFFFBD8F66B82360
...
</code></pre><h1 id="conclusão">Conclusão</h1>
<p>Utilizando a função <code>NtQuerySystemInformation</code>, podemos obter uma grande variedade de informações do sistema de um modo bastante simples. No próximo artigo vamos utilizar essas funções para realizar uma <em>dll injection</em> de forma nativa.</p>
</div>
				
				<footer class="entry__footer">
					
<div class="entry__tags">
			<a class="entry__tag btn" href="/blog/tags/native-dll/">native-dll</a>
			<a class="entry__tag btn" href="/blog/tags/dev/">dev</a>
</div>
					
				</footer>
				
			</article>
		</div>
	</main>
	
	



	

	</div>
	<footer class="footer">
	<div class="footer__copyright">© 2024 RSI. <span class="footer__copyright-credits">Powered by <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/vimux/binario" rel="nofollow noopener" target="_blank">Binario</a> theme.</span></div>
</footer>
<script src="/blog/js/menu.js"></script>
</body>
</html>
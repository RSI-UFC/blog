<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>native-dll on RSI</title>
    <link>https://www.rsiproject.org/blog/tags/native-dll/</link>
    <description>Recent content in native-dll on RSI</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>pt-br</language>
    <lastBuildDate>Mon, 25 Dec 2023 09:03:20 -0800</lastBuildDate>
    <atom:link href="https://www.rsiproject.org/blog/tags/native-dll/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Escrevendo Aplicações Nativas para Windows - Parte 3</title>
      <link>https://www.rsiproject.org/blog/posts/enumhandlers/</link>
      <pubDate>Mon, 25 Dec 2023 09:03:20 -0800</pubDate>
      <guid>https://www.rsiproject.org/blog/posts/enumhandlers/</guid>
      <description>Por Davi Chaves&#xA;O objetivo desse artigo vai ser enumerar todos os processos e, em seguida enumerar todos as threads e handles de um processo específico.&#xA;NtQuerySystemInformation Essa função será usada para pegarmos quase todo tipo de informação do sistema. O primeiro parametro dela é um valor de um enum SYSTEM_INFORMATION_CLASS que vai definir que tipo de informação ela vai trazer. Abaixo a estrutura desse enum. Primeiramente, estaremos utilizando o valor SystemProcessInformation para obtermos uma lista de todos os processos.</description>
    </item>
    <item>
      <title>Escrevendo Aplicações Nativas para Windows - Parte 2</title>
      <link>https://www.rsiproject.org/blog/posts/printf/</link>
      <pubDate>Mon, 18 Dec 2023 09:03:20 -0800</pubDate>
      <guid>https://www.rsiproject.org/blog/posts/printf/</guid>
      <description>Por Davi Chaves&#xA;Até o momento, temos uma aplicação nativa, mas não conseguimos printar nada. Uma forma de construirmos essa funcionalidade seria fazer nosso processo native escrever no standard output do processo pai. Entretanto, eu acabei encontrando algumas dificuldades nessa solução. Dessa forma, vamos utilizar uma outra alternativa: criar um arquivo output.txt e escrever todos as saidas do nosso programa nele.&#xA;Criando e Escrevendo em um Arquivo Para isso, vamos ter que utilizar duas APIs: NtCreateFile e NtWriteFile.</description>
    </item>
    <item>
      <title>Escrevendo Aplicações Nativas para Windows - Parte 1</title>
      <link>https://www.rsiproject.org/blog/posts/construindo-ambiente/</link>
      <pubDate>Tue, 05 Dec 2023 09:03:20 -0800</pubDate>
      <guid>https://www.rsiproject.org/blog/posts/construindo-ambiente/</guid>
      <description>Por Davi Chaves&#xA;O objetivo desse artigo é montarmos um binário que dependa exclusivamente da ntdll.dll. Abaixo estão algumas funções exportadas por essa biblioteca.&#xA;Using Native Functions Antes de construirmos uma aplicação que dependa apenas da ntdll.dll, vamos primeiro aprender a como utilizar as funções dessa biblioteca.&#xA;Primeiro Método: Dynamic Linking Como toda função exportada, podemos utilizar a função GetProcAddress para acharmos o endereço de uma certa função e chama-la quando quisermos.</description>
    </item>
  </channel>
</rss>
